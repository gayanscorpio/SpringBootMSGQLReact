{"ast":null,"code":"import { i as isObject, G as GRAPHQL_TRANSPORT_WS_PROTOCOL, s as stringifyMessage, M as MessageType, C as CloseCode, l as limitCloseReason, p as parseMessage } from './common-CGW11Fyb.js';\nexport { D as DEPRECATED_GRAPHQL_WS_PROTOCOL, v as validateMessage } from './common-CGW11Fyb.js';\nfunction createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      const retryDelaySeconds = Math.pow(2, retries2);\n      await new Promise(resolve => setTimeout(resolve, retryDelaySeconds * 1e3 +\n      // add random timeout from 300ms to 3s\n      Math.floor(Math.random() * (3e3 - 300) + 300)));\n    },\n    shouldRetry = isLikeCloseEvent,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n          v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws = global.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws = window.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n  const WebSocketImpl = ws;\n  const emitter = (() => {\n    const message = /* @__PURE__ */(() => {\n      const listeners2 = {};\n      return {\n        on(id, listener) {\n          listeners2[id] = listener;\n          return () => {\n            delete listeners2[id];\n          };\n        },\n        emit(message2) {\n          if (\"id\" in message2) listeners2[message2.id]?.(message2);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: on?.connecting ? [on.connecting] : [],\n      opened: on?.opened ? [on.opened] : [],\n      connected: on?.connected ? [on.connected] : [],\n      ping: on?.ping ? [on.ping] : [],\n      pong: on?.pong ? [on.pong] : [],\n      message: on?.message ? [message.emit, on.message] : [message.emit],\n      closed: on?.closed ? [on.closed] : [],\n      error: on?.error ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb) {\n    const listening = [\n    // errors are fatal and more critical than close events, throw them first\n    emitter.on(\"error\", err => {\n      listening.forEach(unlisten => unlisten());\n      cb(err);\n    }),\n    // closes can be graceful and not fatal, throw them second (if error didnt throw)\n    emitter.on(\"closed\", event => {\n      listening.forEach(unlisten => unlisten());\n      cb(event);\n    })];\n  }\n  let connecting,\n    locks = 0,\n    lazyCloseTimeout,\n    retrying = false,\n    retries = 0,\n    disposed = false;\n  async function connect() {\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise((connected, denied) => (async () => {\n      if (retrying) {\n        await retryWait(retries);\n        if (!locks) {\n          connecting = void 0;\n          return denied({\n            code: 1e3,\n            reason: \"All Subscriptions Gone\"\n          });\n        }\n        retries++;\n      }\n      emitter.emit(\"connecting\", retrying);\n      const socket2 = new WebSocketImpl(typeof url === \"function\" ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n      let connectionAckTimeout, queuedPing;\n      function enqueuePing() {\n        if (isFinite(keepAlive) && keepAlive > 0) {\n          clearTimeout(queuedPing);\n          queuedPing = setTimeout(() => {\n            if (socket2.readyState === WebSocketImpl.OPEN) {\n              socket2.send(stringifyMessage({\n                type: MessageType.Ping\n              }));\n              emitter.emit(\"ping\", false, void 0);\n            }\n          }, keepAlive);\n        }\n      }\n      errorOrClosed(errOrEvent => {\n        connecting = void 0;\n        clearTimeout(connectionAckTimeout);\n        clearTimeout(queuedPing);\n        denied(errOrEvent);\n        if (errOrEvent instanceof TerminatedCloseEvent) {\n          socket2.close(4499, \"Terminated\");\n          socket2.onerror = null;\n          socket2.onclose = null;\n        }\n      });\n      socket2.onerror = err => emitter.emit(\"error\", err);\n      socket2.onclose = event => emitter.emit(\"closed\", event);\n      socket2.onopen = async () => {\n        try {\n          emitter.emit(\"opened\", socket2);\n          const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n          if (socket2.readyState !== WebSocketImpl.OPEN) return;\n          socket2.send(stringifyMessage(payload ? {\n            type: MessageType.ConnectionInit,\n            payload\n          } : {\n            type: MessageType.ConnectionInit\n            // payload is completely absent if not provided\n          }, replacer));\n          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n            connectionAckTimeout = setTimeout(() => {\n              socket2.close(CloseCode.ConnectionAcknowledgementTimeout, \"Connection acknowledgement timeout\");\n            }, connectionAckWaitTimeout);\n          }\n          enqueuePing();\n        } catch (err) {\n          emitter.emit(\"error\", err);\n          socket2.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : String(err), \"Internal client error\"));\n        }\n      };\n      let acknowledged = false;\n      socket2.onmessage = ({\n        data\n      }) => {\n        try {\n          const message = parseMessage(data, reviver);\n          emitter.emit(\"message\", message);\n          if (message.type === \"ping\" || message.type === \"pong\") {\n            emitter.emit(message.type, true, message.payload);\n            if (message.type === \"pong\") {\n              enqueuePing();\n            } else if (!disablePong) {\n              socket2.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n                // payload is completely absent if not provided\n              }));\n              emitter.emit(\"pong\", false, message.payload);\n            }\n            return;\n          }\n          if (acknowledged) return;\n          if (message.type !== MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n          clearTimeout(connectionAckTimeout);\n          acknowledged = true;\n          emitter.emit(\"connected\", socket2, message.payload, retrying);\n          retrying = false;\n          retries = 0;\n          connected([socket2, new Promise((_, reject) => errorOrClosed(reject))]);\n        } catch (err) {\n          socket2.onmessage = null;\n          emitter.emit(\"error\", err);\n          socket2.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : String(err), \"Bad response\"));\n        }\n      };\n    })())));\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {};\n    const released = new Promise(resolve => release = resolve);\n    return [socket, release, Promise.race([\n    // wait for\n    released.then(() => {\n      if (!locks) {\n        const complete = () => socket.close(1e3, \"Normal Closure\");\n        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n          lazyCloseTimeout = setTimeout(() => {\n            if (socket.readyState === WebSocketImpl.OPEN) complete();\n          }, lazyCloseTimeoutMs);\n        } else {\n          complete();\n        }\n      }\n    }),\n    // or\n    throwOnClose])];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [CloseCode.InternalServerError, CloseCode.InternalClientError, CloseCode.BadRequest, CloseCode.BadResponse, CloseCode.Unauthorized,\n    // CloseCode.Forbidden, might grant access out after retry\n    CloseCode.SubprotocolNotAcceptable,\n    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n    CloseCode.SubscriberAlreadyExists, CloseCode.TooManyInitialisationRequests\n    // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n    if (disposed) return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3) return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (;;) {\n        try {\n          const [,, throwOnClose] = await connect();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError?.(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false,\n      errored = false,\n      releaser = () => {\n        locks--;\n        done = true;\n      };\n    (async () => {\n      locks++;\n      for (;;) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, message => {\n            switch (message.type) {\n              case MessageType.Next:\n                {\n                  sink.next(message.payload);\n                  return;\n                }\n              case MessageType.Error:\n                {\n                  errored = true, done = true;\n                  sink.error(message.payload);\n                  releaser();\n                  return;\n                }\n              case MessageType.Complete:\n                {\n                  done = true;\n                  releaser();\n                  return;\n                }\n            }\n          });\n          socket.send(stringifyMessage({\n            id,\n            type: MessageType.Subscribe,\n            payload\n          }, replacer));\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN) socket.send(stringifyMessage({\n              id,\n              type: MessageType.Complete\n            }, replacer));\n            locks--;\n            done = true;\n            release();\n          };\n          await waitForReleaseOrThrowOnClose.finally(unlisten);\n          return;\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      if (!errored) sink.complete();\n    }).catch(err => {\n      sink.error(err);\n    });\n    return () => {\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {}\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = async function* iterator2() {\n        for (;;) {\n          if (!pending.length) {\n            await new Promise(resolve => deferred.resolve = resolve);\n          }\n          while (pending.length) {\n            yield pending.shift();\n          }\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async err => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return {\n          done: true,\n          value: void 0\n        };\n      };\n      iterator.return = async () => {\n        dispose();\n        return {\n          done: true,\n          value: void 0\n        };\n      };\n      return iterator;\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    },\n    terminate() {\n      if (connecting) {\n        emitter.emit(\"closed\", new TerminatedCloseEvent());\n      }\n    }\n  };\n}\nclass TerminatedCloseEvent extends Error {\n  name = \"TerminatedCloseEvent\";\n  message = \"4499: Terminated\";\n  code = 4499;\n  reason = \"Terminated\";\n  wasClean = false;\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([1e3,\n  // Normal Closure is not an erroneous close code\n  1001,\n  // Going Away\n  1006,\n  // Abnormal Closure\n  1005,\n  // No Status Received\n  1012,\n  // Service Restart\n  1013,\n  // Try Again Later\n  1014\n  // Bad Gateway\n  ].includes(code)) return false;\n  return code >= 1e3 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\nexport { CloseCode, GRAPHQL_TRANSPORT_WS_PROTOCOL, MessageType, TerminatedCloseEvent, createClient, parseMessage, stringifyMessage };","map":{"version":3,"names":["i","isObject","G","GRAPHQL_TRANSPORT_WS_PROTOCOL","s","stringifyMessage","M","MessageType","C","CloseCode","l","limitCloseReason","p","parseMessage","D","DEPRECATED_GRAPHQL_WS_PROTOCOL","v","validateMessage","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","randomisedExponentialBackoff","retries2","retryDelaySeconds","Math","pow","Promise","resolve","setTimeout","floor","random","shouldRetry","isLikeCloseEvent","on","webSocketImpl","generateID","generateUUID","replace","c","r","toString","jsonMessageReplacer","replacer","jsonMessageReviver","reviver","ws","isWebSocket","Error","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners2","id","listener","emit","message2","listeners","connecting","opened","connected","ping","pong","closed","onMessage","event","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","retries","disposed","connect","clearTimeout","socket","throwOnClose","denied","code","reason","socket2","connectionAckTimeout","queuedPing","enqueuePing","isFinite","readyState","OPEN","send","type","Ping","errOrEvent","TerminatedCloseEvent","close","onerror","onclose","onopen","payload","ConnectionInit","ConnectionAcknowledgementTimeout","InternalClientError","String","acknowledged","onmessage","data","Pong","ConnectionAck","_","reject","BadResponse","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","errOrCloseEvent2","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","Next","next","Complete","Subscribe","finally","catch","iterate","request","pending","deferred","dispose","val","iterator","iterator2","length","shift","throw","value","return","terminate","name","wasClean"],"sources":["/Users/gayankumara/SpringBootMSGQLReact/subscription-test/node_modules/graphql-ws/dist/client.js"],"sourcesContent":["import { i as isObject, G as GRAPHQL_TRANSPORT_WS_PROTOCOL, s as stringifyMessage, M as MessageType, C as CloseCode, l as limitCloseReason, p as parseMessage } from './common-CGW11Fyb.js';\nexport { D as DEPRECATED_GRAPHQL_WS_PROTOCOL, v as validateMessage } from './common-CGW11Fyb.js';\n\nfunction createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      const retryDelaySeconds = Math.pow(2, retries2);\n      await new Promise(\n        (resolve) => setTimeout(\n          resolve,\n          retryDelaySeconds * 1e3 + // add random timeout from 300ms to 3s\n          Math.floor(Math.random() * (3e3 - 300) + 300)\n        )\n      );\n    },\n    shouldRetry = isLikeCloseEvent,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws = global.WebSocket || // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws = window.WebSocket || // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws)\n    throw new Error(\n      \"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\"\n    );\n  const WebSocketImpl = ws;\n  const emitter = (() => {\n    const message = /* @__PURE__ */ (() => {\n      const listeners2 = {};\n      return {\n        on(id, listener) {\n          listeners2[id] = listener;\n          return () => {\n            delete listeners2[id];\n          };\n        },\n        emit(message2) {\n          if (\"id\" in message2) listeners2[message2.id]?.(message2);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: on?.connecting ? [on.connecting] : [],\n      opened: on?.opened ? [on.opened] : [],\n      connected: on?.connected ? [on.connected] : [],\n      ping: on?.ping ? [on.ping] : [],\n      pong: on?.pong ? [on.pong] : [],\n      message: on?.message ? [message.emit, on.message] : [message.emit],\n      closed: on?.closed ? [on.closed] : [],\n      error: on?.error ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb) {\n    const listening = [\n      // errors are fatal and more critical than close events, throw them first\n      emitter.on(\"error\", (err) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(err);\n      }),\n      // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on(\"closed\", (event) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(event);\n      })\n    ];\n  }\n  let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n  async function connect() {\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise(\n      (connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries);\n          if (!locks) {\n            connecting = void 0;\n            return denied({ code: 1e3, reason: \"All Subscriptions Gone\" });\n          }\n          retries++;\n        }\n        emitter.emit(\"connecting\", retrying);\n        const socket2 = new WebSocketImpl(\n          typeof url === \"function\" ? await url() : url,\n          GRAPHQL_TRANSPORT_WS_PROTOCOL\n        );\n        let connectionAckTimeout, queuedPing;\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing);\n            queuedPing = setTimeout(() => {\n              if (socket2.readyState === WebSocketImpl.OPEN) {\n                socket2.send(stringifyMessage({ type: MessageType.Ping }));\n                emitter.emit(\"ping\", false, void 0);\n              }\n            }, keepAlive);\n          }\n        }\n        errorOrClosed((errOrEvent) => {\n          connecting = void 0;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n          if (errOrEvent instanceof TerminatedCloseEvent) {\n            socket2.close(4499, \"Terminated\");\n            socket2.onerror = null;\n            socket2.onclose = null;\n          }\n        });\n        socket2.onerror = (err) => emitter.emit(\"error\", err);\n        socket2.onclose = (event) => emitter.emit(\"closed\", event);\n        socket2.onopen = async () => {\n          try {\n            emitter.emit(\"opened\", socket2);\n            const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n            if (socket2.readyState !== WebSocketImpl.OPEN) return;\n            socket2.send(\n              stringifyMessage(\n                payload ? {\n                  type: MessageType.ConnectionInit,\n                  payload\n                } : {\n                  type: MessageType.ConnectionInit\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket2.close(\n                  CloseCode.ConnectionAcknowledgementTimeout,\n                  \"Connection acknowledgement timeout\"\n                );\n              }, connectionAckWaitTimeout);\n            }\n            enqueuePing();\n          } catch (err) {\n            emitter.emit(\"error\", err);\n            socket2.close(\n              CloseCode.InternalClientError,\n              limitCloseReason(\n                err instanceof Error ? err.message : String(err),\n                \"Internal client error\"\n              )\n            );\n          }\n        };\n        let acknowledged = false;\n        socket2.onmessage = ({ data }) => {\n          try {\n            const message = parseMessage(data, reviver);\n            emitter.emit(\"message\", message);\n            if (message.type === \"ping\" || message.type === \"pong\") {\n              emitter.emit(message.type, true, message.payload);\n              if (message.type === \"pong\") {\n                enqueuePing();\n              } else if (!disablePong) {\n                socket2.send(\n                  stringifyMessage(\n                    message.payload ? {\n                      type: MessageType.Pong,\n                      payload: message.payload\n                    } : {\n                      type: MessageType.Pong\n                      // payload is completely absent if not provided\n                    }\n                  )\n                );\n                emitter.emit(\"pong\", false, message.payload);\n              }\n              return;\n            }\n            if (acknowledged) return;\n            if (message.type !== MessageType.ConnectionAck)\n              throw new Error(\n                `First message cannot be of type ${message.type}`\n              );\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit(\"connected\", socket2, message.payload, retrying);\n            retrying = false;\n            retries = 0;\n            connected([\n              socket2,\n              new Promise((_, reject) => errorOrClosed(reject))\n            ]);\n          } catch (err) {\n            socket2.onmessage = null;\n            emitter.emit(\"error\", err);\n            socket2.close(\n              CloseCode.BadResponse,\n              limitCloseReason(\n                err instanceof Error ? err.message : String(err),\n                \"Bad response\"\n              )\n            );\n          }\n        };\n      })()\n    )));\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {\n    };\n    const released = new Promise((resolve) => release = resolve);\n    return [\n      socket,\n      release,\n      Promise.race([\n        // wait for\n        released.then(() => {\n          if (!locks) {\n            const complete = () => socket.close(1e3, \"Normal Closure\");\n            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n              lazyCloseTimeout = setTimeout(() => {\n                if (socket.readyState === WebSocketImpl.OPEN) complete();\n              }, lazyCloseTimeoutMs);\n            } else {\n              complete();\n            }\n          }\n        }),\n        // or\n        throwOnClose\n      ])\n    ];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n      CloseCode.InternalServerError,\n      CloseCode.InternalClientError,\n      CloseCode.BadRequest,\n      CloseCode.BadResponse,\n      CloseCode.Unauthorized,\n      // CloseCode.Forbidden, might grant access out after retry\n      CloseCode.SubprotocolNotAcceptable,\n      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      CloseCode.SubscriberAlreadyExists,\n      CloseCode.TooManyInitialisationRequests\n      // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code)))\n      throw errOrCloseEvent;\n    if (disposed) return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)\n      return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [, , throwOnClose] = await connect();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError?.(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false, errored = false, releaser = () => {\n      locks--;\n      done = true;\n    };\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, (message) => {\n            switch (message.type) {\n              case MessageType.Next: {\n                sink.next(message.payload);\n                return;\n              }\n              case MessageType.Error: {\n                errored = true, done = true;\n                sink.error(message.payload);\n                releaser();\n                return;\n              }\n              case MessageType.Complete: {\n                done = true;\n                releaser();\n                return;\n              }\n            }\n          });\n          socket.send(\n            stringifyMessage(\n              {\n                id,\n                type: MessageType.Subscribe,\n                payload\n              },\n              replacer\n            )\n          );\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN)\n              socket.send(\n                stringifyMessage(\n                  {\n                    id,\n                    type: MessageType.Complete\n                  },\n                  replacer\n                )\n              );\n            locks--;\n            done = true;\n            release();\n          };\n          await waitForReleaseOrThrowOnClose.finally(unlisten);\n          return;\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      if (!errored) sink.complete();\n    }).catch((err) => {\n      sink.error(err);\n    });\n    return () => {\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = async function* iterator2() {\n        for (; ; ) {\n          if (!pending.length) {\n            await new Promise((resolve) => deferred.resolve = resolve);\n          }\n          while (pending.length) {\n            yield pending.shift();\n          }\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async (err) => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return { done: true, value: void 0 };\n      };\n      iterator.return = async () => {\n        dispose();\n        return { done: true, value: void 0 };\n      };\n      return iterator;\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    },\n    terminate() {\n      if (connecting) {\n        emitter.emit(\"closed\", new TerminatedCloseEvent());\n      }\n    }\n  };\n}\nclass TerminatedCloseEvent extends Error {\n  name = \"TerminatedCloseEvent\";\n  message = \"4499: Terminated\";\n  code = 4499;\n  reason = \"Terminated\";\n  wasClean = false;\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([\n    1e3,\n    // Normal Closure is not an erroneous close code\n    1001,\n    // Going Away\n    1006,\n    // Abnormal Closure\n    1005,\n    // No Status Received\n    1012,\n    // Service Restart\n    1013,\n    // Try Again Later\n    1014\n    // Bad Gateway\n  ].includes(code))\n    return false;\n  return code >= 1e3 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n\nexport { CloseCode, GRAPHQL_TRANSPORT_WS_PROTOCOL, MessageType, TerminatedCloseEvent, createClient, parseMessage, stringifyMessage };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}