{"ast":null,"code":"import { parse, validate, getOperationAST, GraphQLError, subscribe, execute, versionInfo } from 'graphql';\nimport { G as GRAPHQL_TRANSPORT_WS_PROTOCOL, C as CloseCode, p as parseMessage, M as MessageType, a as isAsyncGenerator, b as isAsyncIterable, s as stringifyMessage, i as isObject } from './common-CGW11Fyb.js';\nfunction makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate: validate$1,\n    execute: execute$1,\n    subscribe: subscribe$1,\n    connectionInitWaitTimeout = 3e3,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, \"Subprotocol not acceptable\");\n        return async (code, reason) => {\n          await onClose?.(ctx, code, reason);\n        };\n      }\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, \"Connection initialisation timeout\");\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        let message;\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, \"Invalid message received\");\n        }\n        switch (message.type) {\n          case MessageType.ConnectionInit:\n            {\n              if (ctx.connectionInitReceived) return socket.close(CloseCode.TooManyInitialisationRequests, \"Too many initialisation requests\");\n              ctx.connectionInitReceived = true;\n              if (isObject(message.payload)) ctx.connectionParams = message.payload;\n              const permittedOrPayload = await onConnect?.(ctx);\n              if (permittedOrPayload === false) return socket.close(CloseCode.Forbidden, \"Forbidden\");\n              ctx.acknowledged = true;\n              await socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                type: MessageType.ConnectionAck,\n                payload: permittedOrPayload\n              } : {\n                type: MessageType.ConnectionAck\n                // payload is completely absent if not provided\n              }, replacer));\n              return;\n            }\n          case MessageType.Ping:\n            {\n              if (socket.onPing) return await socket.onPing(message.payload);\n              await socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n                // payload is completely absent if not provided\n              }));\n              return;\n            }\n          case MessageType.Pong:\n            return await socket.onPong?.(message.payload);\n          case MessageType.Subscribe:\n            {\n              if (!ctx.acknowledged) return socket.close(CloseCode.Unauthorized, \"Unauthorized\");\n              const {\n                id,\n                payload\n              } = message;\n              if (id in ctx.subscriptions) return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n              ctx.subscriptions[id] = null;\n              const emit = {\n                next: async (result, {\n                  id: id2,\n                  payload: payload2\n                }, args) => {\n                  const {\n                    errors,\n                    ...resultWithoutErrors\n                  } = result;\n                  const maybeResult = await onNext?.(ctx, id2, payload2, args, result);\n                  await socket.send(stringifyMessage({\n                    id: id2,\n                    type: MessageType.Next,\n                    payload: maybeResult || {\n                      ...resultWithoutErrors,\n                      // omit errors completely if not defined\n                      ...(errors ? {\n                        errors: errors.map(e => e.toJSON())\n                      } : {})\n                    }\n                  }, replacer));\n                },\n                error: async (errors, {\n                  id: id2,\n                  payload: payload2\n                }) => {\n                  const maybeErrors = await onError?.(ctx, id2, payload2, errors);\n                  await socket.send(stringifyMessage({\n                    id: id2,\n                    type: MessageType.Error,\n                    payload: maybeErrors || errors.map(e => e.toJSON())\n                  }, replacer));\n                },\n                complete: async (notifyClient, {\n                  id: id2,\n                  payload: payload2\n                }) => {\n                  await onComplete?.(ctx, id2, payload2);\n                  if (notifyClient) await socket.send(stringifyMessage({\n                    id: id2,\n                    type: MessageType.Complete\n                  }, replacer));\n                }\n              };\n              try {\n                let execArgs;\n                const maybeExecArgsOrErrors = await onSubscribe?.(ctx, message.id, message.payload);\n                if (maybeExecArgsOrErrors) {\n                  if (areGraphQLErrors(maybeExecArgsOrErrors)) return id in ctx.subscriptions ? await emit.error(maybeExecArgsOrErrors, message) : void 0;else if (Array.isArray(maybeExecArgsOrErrors)) throw new Error(\"Invalid return value from onSubscribe hook, expected an array of GraphQLError objects\");\n                  execArgs = maybeExecArgsOrErrors;\n                } else {\n                  if (!schema) throw new Error(\"The GraphQL schema is not provided\");\n                  const args = {\n                    operationName: payload.operationName,\n                    document: parse(payload.query),\n                    variableValues: payload.variables\n                  };\n                  execArgs = {\n                    ...args,\n                    schema: typeof schema === \"function\" ? await schema(ctx, id, payload, args) : schema\n                  };\n                  const validationErrors = (validate$1 ?? validate)(execArgs.schema, execArgs.document);\n                  if (validationErrors.length > 0) return id in ctx.subscriptions ? await emit.error(validationErrors, message) : void 0;\n                }\n                const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                if (!operationAST) return id in ctx.subscriptions ? await emit.error([new GraphQLError(\"Unable to identify operation\")], message) : void 0;\n                if (!(\"rootValue\" in execArgs)) execArgs.rootValue = roots?.[operationAST.operation];\n                if (!(\"contextValue\" in execArgs)) execArgs.contextValue = typeof context === \"function\" ? await context(ctx, id, payload, execArgs) : context;\n                let operationResult;\n                if (operationAST.operation === \"subscription\") operationResult = await (subscribe$1 ?? subscribe)(execArgs);else operationResult = await (execute$1 ?? execute)(execArgs);\n                const maybeResult = await onOperation?.(ctx, id, payload, execArgs, operationResult);\n                if (maybeResult) operationResult = maybeResult;\n                if (isAsyncIterable(operationResult)) {\n                  if (!(id in ctx.subscriptions)) {\n                    if (isAsyncGenerator(operationResult)) operationResult.return(void 0);\n                  } else {\n                    ctx.subscriptions[id] = operationResult;\n                    try {\n                      for await (const result of operationResult) {\n                        await emit.next(result, message, execArgs);\n                      }\n                    } catch (err) {\n                      const originalError = err instanceof Error ? err : new Error(String(err));\n                      await emit.error([versionInfo.major >= 16 ? new GraphQLError(originalError.message,\n                      // @ts-ignore graphql@15 and less dont have the second arg as object (version is ensured by versionInfo.major check above)\n                      {\n                        originalError\n                      }) :\n                      // versionInfo.major <= 15\n                      new GraphQLError(originalError.message, null, null, null, null, originalError)], message);\n                    }\n                  }\n                } else {\n                  if (id in ctx.subscriptions) await emit.next(operationResult, message, execArgs);\n                }\n                await emit.complete(id in ctx.subscriptions, message);\n              } finally {\n                delete ctx.subscriptions[id];\n              }\n              return;\n            }\n          case MessageType.Complete:\n            {\n              const subscription = ctx.subscriptions[message.id];\n              delete ctx.subscriptions[message.id];\n              if (isAsyncGenerator(subscription)) await subscription.return(void 0);\n              return;\n            }\n          default:\n            throw new Error(`Unexpected message of type ${message.type} received`);\n        }\n      });\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n        const subs = {\n          ...ctx.subscriptions\n        };\n        ctx.subscriptions = {};\n        await Promise.all(Object.values(subs).filter(isAsyncGenerator).map(sub => sub.return(void 0)));\n        if (ctx.acknowledged) await onDisconnect?.(ctx, code, reason);\n        await onClose?.(ctx, code, reason);\n      };\n    }\n  };\n}\nfunction handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === \"string\" && protocols.split(\",\").map(p => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}\nfunction areGraphQLErrors(obj) {\n  return Array.isArray(obj) &&\n  // must be at least one error\n  obj.length > 0 &&\n  // error has at least a message\n  obj.every(ob => ob instanceof GraphQLError);\n}\nexport { areGraphQLErrors as a, handleProtocols as h, makeServer as m };","map":{"version":3,"names":["parse","validate","getOperationAST","GraphQLError","subscribe","execute","versionInfo","G","GRAPHQL_TRANSPORT_WS_PROTOCOL","C","CloseCode","p","parseMessage","M","MessageType","a","isAsyncGenerator","b","isAsyncIterable","s","stringifyMessage","i","isObject","makeServer","options","schema","context","roots","validate$1","execute$1","subscribe$1","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","jsonMessageReviver","reviver","jsonMessageReplacer","replacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","code","reason","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","data","message","err","BadRequest","type","ConnectionInit","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","Ping","onPing","Pong","onPong","Subscribe","Unauthorized","id","SubscriberAlreadyExists","emit","next","result","id2","payload2","args","errors","resultWithoutErrors","maybeResult","Next","map","e","toJSON","error","maybeErrors","Error","complete","notifyClient","Complete","execArgs","maybeExecArgsOrErrors","areGraphQLErrors","Array","isArray","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","originalError","String","major","subscription","clearTimeout","subs","Promise","all","Object","values","filter","sub","handleProtocols","protocols","Set","has","includes","split","trim","obj","every","ob","h","m"],"sources":["/Users/gayankumara/SpringBootMSGQLReact/subscription-test/node_modules/graphql-ws/dist/server-3ewaJSjp.js"],"sourcesContent":["import { parse, validate, getOperationAST, GraphQLError, subscribe, execute, versionInfo } from 'graphql';\nimport { G as GRAPHQL_TRANSPORT_WS_PROTOCOL, C as CloseCode, p as parseMessage, M as MessageType, a as isAsyncGenerator, b as isAsyncIterable, s as stringifyMessage, i as isObject } from './common-CGW11Fyb.js';\n\nfunction makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate: validate$1,\n    execute: execute$1,\n    subscribe: subscribe$1,\n    connectionInitWaitTimeout = 3e3,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(\n          CloseCode.SubprotocolNotAcceptable,\n          \"Subprotocol not acceptable\"\n        );\n        return async (code, reason) => {\n          await onClose?.(ctx, code, reason);\n        };\n      }\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived)\n          socket.close(\n            CloseCode.ConnectionInitialisationTimeout,\n            \"Connection initialisation timeout\"\n          );\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        let message;\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, \"Invalid message received\");\n        }\n        switch (message.type) {\n          case MessageType.ConnectionInit: {\n            if (ctx.connectionInitReceived)\n              return socket.close(\n                CloseCode.TooManyInitialisationRequests,\n                \"Too many initialisation requests\"\n              );\n            ctx.connectionInitReceived = true;\n            if (isObject(message.payload))\n              ctx.connectionParams = message.payload;\n            const permittedOrPayload = await onConnect?.(ctx);\n            if (permittedOrPayload === false)\n              return socket.close(CloseCode.Forbidden, \"Forbidden\");\n            ctx.acknowledged = true;\n            await socket.send(\n              stringifyMessage(\n                isObject(permittedOrPayload) ? {\n                  type: MessageType.ConnectionAck,\n                  payload: permittedOrPayload\n                } : {\n                  type: MessageType.ConnectionAck\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            return;\n          }\n          case MessageType.Ping: {\n            if (socket.onPing)\n              return await socket.onPing(message.payload);\n            await socket.send(\n              stringifyMessage(\n                message.payload ? { type: MessageType.Pong, payload: message.payload } : {\n                  type: MessageType.Pong\n                  // payload is completely absent if not provided\n                }\n              )\n            );\n            return;\n          }\n          case MessageType.Pong:\n            return await socket.onPong?.(message.payload);\n          case MessageType.Subscribe: {\n            if (!ctx.acknowledged)\n              return socket.close(CloseCode.Unauthorized, \"Unauthorized\");\n            const { id, payload } = message;\n            if (id in ctx.subscriptions)\n              return socket.close(\n                CloseCode.SubscriberAlreadyExists,\n                `Subscriber for ${id} already exists`\n              );\n            ctx.subscriptions[id] = null;\n            const emit = {\n              next: async (result, { id: id2, payload: payload2 }, args) => {\n                const { errors, ...resultWithoutErrors } = result;\n                const maybeResult = await onNext?.(\n                  ctx,\n                  id2,\n                  payload2,\n                  args,\n                  result\n                );\n                await socket.send(\n                  stringifyMessage(\n                    {\n                      id: id2,\n                      type: MessageType.Next,\n                      payload: maybeResult || {\n                        ...resultWithoutErrors,\n                        // omit errors completely if not defined\n                        ...errors ? { errors: errors.map((e) => e.toJSON()) } : {}\n                      }\n                    },\n                    replacer\n                  )\n                );\n              },\n              error: async (errors, { id: id2, payload: payload2 }) => {\n                const maybeErrors = await onError?.(ctx, id2, payload2, errors);\n                await socket.send(\n                  stringifyMessage(\n                    {\n                      id: id2,\n                      type: MessageType.Error,\n                      payload: maybeErrors || errors.map((e) => e.toJSON())\n                    },\n                    replacer\n                  )\n                );\n              },\n              complete: async (notifyClient, { id: id2, payload: payload2 }) => {\n                await onComplete?.(ctx, id2, payload2);\n                if (notifyClient)\n                  await socket.send(\n                    stringifyMessage(\n                      {\n                        id: id2,\n                        type: MessageType.Complete\n                      },\n                      replacer\n                    )\n                  );\n              }\n            };\n            try {\n              let execArgs;\n              const maybeExecArgsOrErrors = await onSubscribe?.(\n                ctx,\n                message.id,\n                message.payload\n              );\n              if (maybeExecArgsOrErrors) {\n                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                  return id in ctx.subscriptions ? await emit.error(maybeExecArgsOrErrors, message) : void 0;\n                else if (Array.isArray(maybeExecArgsOrErrors))\n                  throw new Error(\n                    \"Invalid return value from onSubscribe hook, expected an array of GraphQLError objects\"\n                  );\n                execArgs = maybeExecArgsOrErrors;\n              } else {\n                if (!schema)\n                  throw new Error(\"The GraphQL schema is not provided\");\n                const args = {\n                  operationName: payload.operationName,\n                  document: parse(payload.query),\n                  variableValues: payload.variables\n                };\n                execArgs = {\n                  ...args,\n                  schema: typeof schema === \"function\" ? await schema(ctx, id, payload, args) : schema\n                };\n                const validationErrors = (validate$1 ?? validate)(\n                  execArgs.schema,\n                  execArgs.document\n                );\n                if (validationErrors.length > 0)\n                  return id in ctx.subscriptions ? await emit.error(validationErrors, message) : void 0;\n              }\n              const operationAST = getOperationAST(\n                execArgs.document,\n                execArgs.operationName\n              );\n              if (!operationAST)\n                return id in ctx.subscriptions ? await emit.error(\n                  [new GraphQLError(\"Unable to identify operation\")],\n                  message\n                ) : void 0;\n              if (!(\"rootValue\" in execArgs))\n                execArgs.rootValue = roots?.[operationAST.operation];\n              if (!(\"contextValue\" in execArgs))\n                execArgs.contextValue = typeof context === \"function\" ? await context(ctx, id, payload, execArgs) : context;\n              let operationResult;\n              if (operationAST.operation === \"subscription\")\n                operationResult = await (subscribe$1 ?? subscribe)(\n                  execArgs\n                );\n              else\n                operationResult = await (execute$1 ?? execute)(execArgs);\n              const maybeResult = await onOperation?.(\n                ctx,\n                id,\n                payload,\n                execArgs,\n                operationResult\n              );\n              if (maybeResult) operationResult = maybeResult;\n              if (isAsyncIterable(operationResult)) {\n                if (!(id in ctx.subscriptions)) {\n                  if (isAsyncGenerator(operationResult))\n                    operationResult.return(void 0);\n                } else {\n                  ctx.subscriptions[id] = operationResult;\n                  try {\n                    for await (const result of operationResult) {\n                      await emit.next(result, message, execArgs);\n                    }\n                  } catch (err) {\n                    const originalError = err instanceof Error ? err : new Error(String(err));\n                    await emit.error(\n                      [\n                        versionInfo.major >= 16 ? new GraphQLError(\n                          originalError.message,\n                          // @ts-ignore graphql@15 and less dont have the second arg as object (version is ensured by versionInfo.major check above)\n                          { originalError }\n                        ) : (\n                          // versionInfo.major <= 15\n                          new GraphQLError(\n                            originalError.message,\n                            null,\n                            null,\n                            null,\n                            null,\n                            originalError\n                          )\n                        )\n                      ],\n                      message\n                    );\n                  }\n                }\n              } else {\n                if (id in ctx.subscriptions)\n                  await emit.next(operationResult, message, execArgs);\n              }\n              await emit.complete(id in ctx.subscriptions, message);\n            } finally {\n              delete ctx.subscriptions[id];\n            }\n            return;\n          }\n          case MessageType.Complete: {\n            const subscription = ctx.subscriptions[message.id];\n            delete ctx.subscriptions[message.id];\n            if (isAsyncGenerator(subscription))\n              await subscription.return(void 0);\n            return;\n          }\n          default:\n            throw new Error(\n              `Unexpected message of type ${message.type} received`\n            );\n        }\n      });\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n        const subs = { ...ctx.subscriptions };\n        ctx.subscriptions = {};\n        await Promise.all(\n          Object.values(subs).filter(isAsyncGenerator).map((sub) => sub.return(void 0))\n        );\n        if (ctx.acknowledged) await onDisconnect?.(ctx, code, reason);\n        await onClose?.(ctx, code, reason);\n      };\n    }\n  };\n}\nfunction handleProtocols(protocols) {\n  switch (true) {\n    case (protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n    case (Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n    case (typeof protocols === \"string\" && protocols.split(\",\").map((p) => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}\nfunction areGraphQLErrors(obj) {\n  return Array.isArray(obj) && // must be at least one error\n  obj.length > 0 && // error has at least a message\n  obj.every((ob) => ob instanceof GraphQLError);\n}\n\nexport { areGraphQLErrors as a, handleProtocols as h, makeServer as m };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}